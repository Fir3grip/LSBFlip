<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Canvas Fingerprint — Bitflip Blocker</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body { font-family: system-ui, -apple-system, "Segoe UI", Roboto, sans-serif; padding: 24px; }
    canvas { border: 1px solid #ccc; display:block; margin-bottom:12px; }
    .fingerprint { font-family: monospace; background:#f6f6f6; padding:8px; border-radius:4px; }
    button { margin-top:8px; }
    .controls { margin-top:16px; background:#f0f4f8; padding:12px; border-radius:6px; }
    .controls label { display:block; margin-top:8px; }
  </style>
</head>
<body>
  <h1>Canvas Fingerprint — Bitflip Blocker</h1>
  <canvas id="fpCanvas" width="400" height="120"></canvas>
  <div>
    <strong>Fingerprint (SHA-256 hex):</strong>
    <div id="fingerprint" class="fingerprint">—</div>
    <button id="regenerate">Regenerate</button>
    <button id="copy">Copy</button>
  </div>

  <div class="controls">
    <h3>Bitflipping Blocker Controls</h3>
    <label>
      Flip Percentage: <span id="flipPercentLabel">0%</span>
      <input type="range" id="flipPercent" min="0" max="100" value="0">
    </label>
    <label>
      Max Bits to Flip (0–6 LSBs):
      <input type="range" id="bitsToFlip" min="0" max="6" value="0">
      <span id="bitsToFlipLabel">0</span>
    </label>
    <label><input type="checkbox" id="showModified"> Show Modified Pixels (Red Overlay)</label>
    <label><input type="checkbox" id="useSeeded"> Use Seeded Random (Deterministic)</label>
  </div>

  <script>
  /* ---------- Deterministic PRNG ---------- */
  function mulberry32(seed) {
    return function() {
      seed |= 0;
      seed = seed + 0x6D2B79F5 | 0;
      let t = Math.imul(seed ^ seed >>> 15, 1 | seed);
      t ^= t + Math.imul(t ^ t >>> 7, 61 | t);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    };
  }

  function createRandom(useSeeded, params = {}) {
    if (!useSeeded) return Math.random; // If user does not want seed it retirns a random number
    // Combine controls into deterministic seed
    const seedString = `${params.flipPercent}|${params.bitsToFlip}|${params.canvasWidth}|${params.canvasHeight}`;
    let seed = 0;
    for (let i = 0; i < seedString.length; i++) {
      seed = (seed * 31 + seedString.charCodeAt(i)) >>> 0;
    }
    return mulberry32(seed);
  }

  /* ---------- Hashing helpers ---------- */
  async function hashArrayToHex(arr) { // Gets hash from SHA-256
    if (crypto?.subtle?.digest) {
      const digest = await crypto.subtle.digest('SHA-256', arr);
      return Array.from(new Uint8Array(digest))
        .map(b => b.toString(16).padStart(2, '0')).join('');
    }
    // fallback (FNV-1a)
    let h = 0x811c9dc5 >>> 0;
    for (const b of arr) {
      h ^= b;
      h = Math.imul(h, 0x01000193) >>> 0;
    }
    return (h >>> 0).toString(16).padStart(8, '0');
  }

  /* ---------- Canvas Drawing + Bitflip ---------- */
  async function generateCanvasFingerprint(canvas, opts) {
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Base draw (deterministic)
    const g = ctx.createLinearGradient(0,0,canvas.width,canvas.height);
    g.addColorStop(0, '#f8f9fb');
    g.addColorStop(1, '#e9f2ff');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    ctx.beginPath();
    ctx.moveTo(10, canvas.height - 10);
    ctx.quadraticCurveTo(canvas.width/2, -20, canvas.width-10, canvas.height-10);
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(30,120,210,0.6)';
    ctx.stroke();

    ctx.save();
    ctx.fillStyle = 'black';
    ctx.textBaseline = 'top';
    ctx.font = '16px "Segoe UI", Roboto, Arial, sans-serif';
    ctx.fillText('Canvas Fingerprint', 12, 12);

    ctx.translate(12, 44);
    ctx.rotate(-0.06);
    ctx.font = 'bold 20px Georgia, "Times New Roman", serif';
    ctx.fillStyle = 'rgba(50,50,50,0.9)';
    ctx.fillText('Render', 0, 0);

    ctx.font = 'italic 14px "Courier New", monospace';
    ctx.fillStyle = 'rgba(80,80,80,0.85)';
    ctx.fillText('sub-pixel variation', 0, 26);
    ctx.restore();

    for (let i = 0; i < 6; i++) {
      ctx.fillStyle = `rgba(${40 + i*20}, ${100 + i*10}, ${160 - i*10}, ${0.5 + i*0.07})`;
      ctx.fillRect(260 + i*18, 12 + (i%2)*8, 14, 14);
      ctx.beginPath();
      ctx.arc(320 + i*12, 80 - i*6, 6 + (i%3), 0, Math.PI*2);
      ctx.fill();
    }

    ctx.lineWidth = 1.2;
    ctx.strokeStyle = 'rgba(10,10,10,0.5)';
    ctx.strokeRect(200, 44, 160, 54);

    // Get pixel data
    const imageData = ctx.getImageData(0,0,canvas.width,canvas.height);
    const data = new Uint8ClampedArray(imageData.data); // copy to avoid mutation issues

    if (opts.flipPercent > 0 && opts.bitsToFlip > 0) {
      const rand = createRandom(opts.useSeeded, { // Parameters are for determined seed
        flipPercent: opts.flipPercent, 
        bitsToFlip: opts.bitsToFlip, 
        canvasWidth: canvas.width, 
        canvasHeight: canvas.height 
      });
      const totalPixels = data.length / 4;
      const pixelsToFlip = Math.floor(totalPixels * (opts.flipPercent / 100));

      for (let i = 0; i < pixelsToFlip; i++) { // For every pixel to flip, based on pixel percentage
        const pxIndex = Math.floor(rand() * totalPixels) * 4;
        for (let c = 0; c < 3; c++) { // For each RGB value
          let val = data[pxIndex + c];
          const bitsToChange = Math.floor(rand() * opts.bitsToFlip) + 1;
          for (let b = 0; b < bitsToChange; b++) { //For each LSB set to flip
            const bitPos = Math.floor(rand() * Math.min(2, opts.bitsToFlip));
            val ^= (1 << bitPos);
          }
          data[pxIndex + c] = val;
        }
      }
      ctx.putImageData(new ImageData(data, canvas.width, canvas.height), 0, 0);

      if (opts.showModified) {
        ctx.save();
        ctx.globalAlpha = 0.5;
        ctx.fillStyle = 'rgba(255,0,0,0.4)';
        const randOverlay = createRandom(opts.useSeeded, { ...opts, canvasWidth: canvas.width, canvasHeight: canvas.height });
        for (let i = 0; i < pixelsToFlip; i++) {
          const px = Math.floor(randOverlay() * canvas.width);
          const py = Math.floor(randOverlay() * canvas.height);
          ctx.fillRect(px, py, 1, 1);
        }
        ctx.restore();
      }
    }

    // Hash deterministic pixel data
    const fingerprintHex = await hashArrayToHex(data);
    return { fingerprintHex };
  }

  /* ---------- UI ---------- */
  (function(){
    const canvas = document.getElementById('fpCanvas');
    const fpDiv = document.getElementById('fingerprint');
    const regen = document.getElementById('regenerate');
    const copy = document.getElementById('copy');
    const flipSlider = document.getElementById('flipPercent');
    const flipLabel = document.getElementById('flipPercentLabel');
    const bitsSlider = document.getElementById('bitsToFlip');
    const bitsLabel = document.getElementById('bitsToFlipLabel');
    const showChk = document.getElementById('showModified');
    const seedChk = document.getElementById('useSeeded');

    async function doGenerate() {
      const opts = {
        flipPercent: parseInt(flipSlider.value),
        bitsToFlip: parseInt(bitsSlider.value),
        showModified: showChk.checked,
        useSeeded: seedChk.checked
      };
      fpDiv.textContent = 'generating…';
      const { fingerprintHex } = await generateCanvasFingerprint(canvas, opts);
      fpDiv.textContent = fingerprintHex;
    }

    flipSlider.addEventListener('input', () => { flipLabel.textContent = flipSlider.value + '%'; doGenerate(); });
    bitsSlider.addEventListener('input', () => { bitsLabel.textContent = bitsSlider.value; doGenerate(); });
    showChk.addEventListener('change', doGenerate);
    seedChk.addEventListener('change', doGenerate);
    regen.addEventListener('click', doGenerate);
    copy.addEventListener('click', async () => {
      const text = fpDiv.textContent;
      if (!text || text === '—' || text === 'generating…') return;
      await navigator.clipboard.writeText(text);
      copy.textContent = 'Copied!';
      setTimeout(() => copy.textContent = 'Copy', 1200);
    });
    window.addEventListener('load', doGenerate);
  })();
  </script>
</body>
</html>
